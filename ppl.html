<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
</head>
<body>
	<canvas id="canvas" width='400' height='600' style='border:1px solid #666'></canvas>
	<button onclick='play()'>play</button>
	<button onclick='start()'>start</button>
</body>
</html>

<script>
	var canvas=document.getElementById('canvas')
	var ctx=canvas.getContext('2d')
	var speed=0.2;//the speed balls get down
	var colors=['red','green','pink','yellow','purple'];
	var balls=[];
	var shotballs=[];
	var shotspeed=20;//the speed shotballs move
	var readys=[colors[Math.floor(Math.random()*colors.length)],colors[Math.floor(Math.random()*colors.length)]];
	appendnoball(7,0);
	canvas.addEventListener('click',shoot);
	
	function play(){
		render();
		update();
	}
	function start(){
		var gamestart=setInterval(function(){
		render();
		update();
	},20);
	}
	function render(){
		ctx.clearRect(0, 0, 400, 600);
		ctx.beginPath();
		ctx.moveTo(0, 450);
		ctx.lineTo(400, 450);
		ctx.stroke();
		drawballs();
		drawreadys();
	}
	function update(){
		//shotballs和balls的碰撞检测
		collisiondetect();
		//判断顶层生成球
		if(balls[0][0].h>=0){
			appendball(balls[0].length,balls[0][0].h);
		}
		//把所有球下降speed高度
		for(var i=0;i<balls.length;i++){
			for(j=0;j<balls[i].length;j++){
				balls[i][j].h+=speed;
			}
		}
		//消失判定/结束判定
		if(balls.length>=12){
			balls.pop();
		}
		//shotballs的更新
		for(var i=0;i<shotballs.length;i++){
			shotballs[i].x+=shotballs[i].vx;
			shotballs[i].y+=shotballs[i].vy;
			if(shotballs[i].x+25>=400){
				shotballs[i].x=400-25;
				shotballs[i].vx*=-1;
			}
			if(shotballs[i].x-25<=0){
				shotballs[i].x=25;
				shotballs[i].vx*=-1;
			}
		}
		

	}
	function appendball(length,height){
		var line=[];
		if(length==7){
				for(var i=0;i<8;i++){
				var ball={'c':colors[Math.floor(Math.random()*colors.length)],'h':height-25*Math.sqrt(3),'x':50*i+25};
				line.push(ball);
			}
		}else{
				for(var i=0;i<7;i++){
				var ball={'c':colors[Math.floor(Math.random()*colors.length)],'h':height-25*Math.sqrt(3),'x':50*i+50};
				line.push(ball);
			}
		}
		
		balls.unshift(line);
	}
	function appendnoball(length,height){
		var line=[];
		if(length==7){
				for(var i=0;i<8;i++){
				var ball={'c':'no','h':height+25*Math.sqrt(3),'x':50*i+25};
				line.push(ball);
			}
		}else{
				for(var i=0;i<7;i++){
				var ball={'c':'no','h':height+25*Math.sqrt(3),'x':50*i+50};
				line.push(ball);
			}
		}
		
		balls.push(line);
	}
	function drawballs(){
		for(var i=0;i<balls.length;i++){
			if(balls[i].length==8){
				for(var j=0;j<8;j++){
					if(balls[i][j].c!='no'){
						ctx.beginPath();
					ctx.arc(50*j+25, balls[i][j].h, 25, 0, 2*Math.PI);
					ctx.fillStyle = balls[i][j].c;
					ctx.fill();
					}
					
				}
			}else{
				for(var k=0;k<7;k++){
					if(balls[i][k].c!='no'){
						ctx.beginPath();
						ctx.arc(50*k+50, balls[i][k].h, 25, 0, 2*Math.PI);
						ctx.fillStyle = balls[i][k].c;
						ctx.fill();
					}
					
				}
			}
		}
		//shotballs
		for(var i=0;i<shotballs.length;i++){
			ctx.beginPath();
			ctx.arc(shotballs[i].x, shotballs[i].y, 25, 0, 2*Math.PI);
			ctx.fillStyle = shotballs[i].c;
			ctx.fill();
		}
	}
	function drawreadys(){
		ctx.beginPath();
		ctx.arc(200, 500, 25, 0, 2*Math.PI);
		ctx.fillStyle = readys[0];
		ctx.fill();
		ctx.beginPath();
		ctx.arc(100, 550 , 17, 0, 2*Math.PI);
		ctx.fillStyle = readys[1];
		ctx.fill();
	}
	function shoot(e){
		var x=e.offsetX;
		var y=e.offsetY;
		//判断位置
		if(y>=450){
			var temp=readys[0];
			readys[0]=readys[1];
			readys[1]=temp;
			return;
		}
		//在shotballs里加球
		var _x=x-200;
		var _y=y-500;
		var speedvector=Math.sqrt(_x*_x+_y*_y);
		var newshotball={'c':readys[0],x:200,y:500,vx:shotspeed/speedvector*_x,vy:shotspeed/speedvector*_y};
		shotballs.push(newshotball);
		//ready改变
		readys[0]=readys[1];
		readys[1]=colors[Math.floor(Math.random()*colors.length)];
	}
	function collisiondetect(){
		if(shotballs.length>0){
			for(var j=0;j<shotballs.length;j++){
				for(var i=balls.length-1;i>=0;i--){
					//入行
					if(balls[i][0].h+25>=shotballs[j].y&&balls[i][0].h-25<shotballs[j].y){
						for(var k=0;k<balls[i].length;k++){
							if(distance(balls[i][k].x,balls[i][k].h,shotballs[j].x,shotballs[j].y)<25){
								var res=checksurroundings(i,k,shotballs[j].c);
								if(res==false){
									return;//不能停靠
								}else{
									if(res.length==1){//停靠
										balls[i][k].c=shotballs[j].c;
										if(balls[i+1]==undefined){
											appendnoball(balls[i].length,balls[i][0].h);
										}
									}else{
										res.shift();//等待被递归查询同色的数组。
										var samecolor=findsamecolor(res);console.log(samecolor)
										if(samecolor.length<2){
												balls[i][k].c=shotballs[j].c;
											if(balls[i+1]==undefined){
												appendnoball(balls[i].length,balls[i][0].h);
											}
										}else{
											for(var l=0;l<samecolor.length;l++){
												balls[samecolor[l][0]][samecolor[l][1]].c='no';
											}
										}
									}
									deleteshotball(j);
								}
							}
						}
					}
				}
			}
		}
	}
	function checksurroundings(line,column,color){//检查周围是否有可以停靠的球
		//返回值：false为没有停靠单位，数组为周围同色的坐标。
		//出来结果需要shift一下。。
		var flag=0;// 0代表不停，如果周围有单位是彩色就设为1
		var color=color;
		var list=[[0,0]];
		var tmp='';
		if(balls[line].length==7){
				tmp=getballcolor(line-1,column);
			if(tmp!='no'&&tmp!='ball_is_not_exist'){flag=1}
			if(tmp==color){list.push([line-1,column])}
				tmp=getballcolor(line-1,column+1);
			if(tmp!='no'&&tmp!='ball_is_not_exist'){flag=1}
			if(tmp==color){list.push([line-1,column+1])}
				tmp=getballcolor(line,column-1);
			if(tmp!='no'&&tmp!='ball_is_not_exist'){flag=1}
			if(tmp==color){list.push([line,column-1])}
				tmp=getballcolor(line,column+1);
			if(tmp!='no'&&tmp!='ball_is_not_exist'){flag=1}
			if(tmp==color){list.push([line,column+1])}
				tmp=getballcolor(line+1,column);
			if(tmp!='no'&&tmp!='ball_is_not_exist'){flag=1}
			if(tmp==color){list.push([line+1,column])}
				tmp=getballcolor(line+1,column+1);
			if(tmp!='no'&&tmp!='ball_is_not_exist'){flag=1}
			if(tmp==color){list.push([line+1,column+1])}
		}
		if(balls[line].length==8){
				tmp=getballcolor(line-1,column);
			if(tmp!='no'&&tmp!='ball_is_not_exist'){flag=1}
			if(tmp==color){list.push([line-1,column])}
				tmp=getballcolor(line-1,column-1);
			if(tmp!='no'&&tmp!='ball_is_not_exist'){flag=1}
			if(tmp==color){list.push([line-1,column-1])}
				tmp=getballcolor(line,column-1);
			if(tmp!='no'&&tmp!='ball_is_not_exist'){flag=1}
			if(tmp==color){list.push([line,column-1])}
				tmp=getballcolor(line,column+1);
			if(tmp!='no'&&tmp!='ball_is_not_exist'){flag=1}
			if(tmp==color){list.push([line,column+1])}
				tmp=getballcolor(line+1,column);
			if(tmp!='no'&&tmp!='ball_is_not_exist'){flag=1}
			if(tmp==color){list.push([line+1,column])}
				tmp=getballcolor(line+1,column-1);
			if(tmp!='no'&&tmp!='ball_is_not_exist'){flag=1}
			if(tmp==color){list.push([line+1,column-1])}
		}
		if(flag==1){
			return list;
		}else{
			return false;
		}
	}
	function getballcolor(line,column){
		if(balls[line]!=undefined){
				if(balls[line][column]!=undefined){
				return balls[line][column].c;
			}else{
				return 'ball_is_not_exist';
			}
		}else{
			return 'ball_is_not_exist';
		}
	}
	function findsamecolor(list){//输入为坐标的数组，输出为周围所有的同色坐标数组
		//思路：遍历list，结果为：1.list周围没有同色，返回结果。2.还有同色，把同色加入list，重新运行。
		var list=list;
		var color=balls[list[0][0]][list[0][1]].c;
		var latestfound=[];
		var arrToBeCheck=list;
		var cycleflag=0;
		while(true){
				cycleflag=0;
				for(var i=0;i<arrToBeCheck.length;i++){//循环待检查的数组
				var tmp=checksurroundings(arrToBeCheck[i][0],arrToBeCheck[i][1],color);
				if(tmp!=false&&tmp.length!=1){
					tmp.shift();
					for(var j=0;j<tmp.length;j++){
						if(!isIndexOf(list,tmp[j])){//若有新结果咋把flag设为1并把结果加入latestfound和list
							cycleflag=1;
							latestfound.push(tmp[j]);
							list.push(tmp[j]);
						}
					}
				}
			}
				if(cycleflag==0){return list;}
				arrToBeCheck=latestfound;
				latestfound=[];
		}
	}
	function deleteshotball(num){
		if(num!=0){
			var tmp=shotballs[num];
		shotballs[num]=shotballs[0];
		shotballs[0]=tmp;
		}
		shotballs.shift();
	}
	function distance(x,y,_x,_y){
		return Math.sqrt((x-_x)*(x-_x)+(y-_y)*(y-_y));
	}
	function isIndexOf(longarr,singlearr){
		var flag=0;
		for(var i=0;i<longarr.length;i++){
			if(singlearr.toString()==longarr[i].toString()){flag=1}
		}
		return flag==1?true:false;
	}


</script>